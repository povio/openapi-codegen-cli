{{! Zod import }}
{{{genImport zodImport}}}
{{! Error handling import }}
{{{genImport errorHandlingImport}}}

export namespace ZodExtended {
  interface ParseOptions {
    type: "body" | "query";
    name?: string;
    errorHandler?: ErrorHandler<never>;
  }

  export function {{parse}}<ZOutput, ZInput>(
    schema: z.ZodType<ZOutput, ZInput>,
    data: unknown,
    { type, name, errorHandler }: ParseOptions = { type: "body" },
  ) {
    try {
      return schema.parse(data);
    } catch (e) {
      if (e instanceof z.ZodError) {
        e.name = `FE Request ${type === "body" ? "body" : "query param"}${name ? ` ("${name}")` : ""} schema mismatch - ZodError`;
      }
      (errorHandler ?? {{sharedErrorHandler}}).rethrowError(e);
      throw e;
    }
  }

  function is{{capitalize sortExp}}Valid(enumSchema: z.ZodEnum, data?: string) {
    if (data === undefined || data === "" || enumSchema.options.length === 0) {
      return true;
    }

    const prefixedEnumOptions = `([+-]?(${enumSchema.options.join("|")}))`;
    const commaSeparatedOptions = `(${prefixedEnumOptions})(\s*,\s*${prefixedEnumOptions})*`;
    return new RegExp(`^${commaSeparatedOptions}$`).test(data);
  }

  export const {{sortExp}} = (enumSchema: z.ZodEnum) =>
    z.string().superRefine((arg, ctx) => {
      if (!is{{capitalize sortExp}}Valid(enumSchema, arg)) {
        ctx.addIssue({
          code: "invalid_value",
          message: "Invalid sorting string.",
          values: [],
        });
      }
    });

  {{#if branded}}
  interface $ZodBrandedDef<T extends z.core.SomeType = z.core.$ZodType, Brand extends string = string>
    extends z.core.$ZodTypeDef {
    type: "custom";
    innerType: T;
    brand: Brand;
  }

  interface $ZodBrandedInternals<T extends z.core.SomeType = z.core.$ZodType, Brand extends string = string>
    extends z.core.$ZodTypeInternals<z.core.output<T>, z.core.input<T>> {
    def: $ZodBrandedDef<T, Brand>;
    optin: T["_zod"]["optin"];
    optout: T["_zod"]["optout"];
    isst: never;
    values: T["_zod"]["values"];
  }

  interface $ZodBranded<T extends z.core.SomeType = z.core.$ZodType, Brand extends string = string>
    extends z.core.$ZodType {
    _zod: $ZodBrandedInternals<T, Brand>;
    unwrap(): T;
  }

  const $ZodBranded: z.core.$constructor<$ZodBranded> = z.core.$constructor("$ZodBranded", (inst, def) => {
    z.core.$ZodType.init(inst, def);
    inst._zod.def.brand = def.brand;
    inst._zod.parse = (payload, ctx) => def.innerType._zod.run(payload, ctx);
  });

  export interface ZodBranded<T extends z.core.SomeType = z.core.$ZodType, Brand extends string = string>
    extends z._ZodType<$ZodBrandedInternals<T, Brand>>,
      $ZodBranded<T, Brand> {
    unwrap(): T;
  }

  export const ZodBranded: z.core.$constructor<ZodBranded> = z.core.$constructor("ZodBranded", (inst, def) => {
    $ZodBranded.init(inst, def);
    z.ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });

  export function {{brand}}<T extends z.core.SomeType, Brand extends string>(
    innerType: T,
    brand: Brand,
  ): ZodBranded<T, Brand> {
    return new ZodBranded({
      type: "custom",
      innerType: innerType as any as z.core.$ZodType,
      brand,
    }) as any;
  }
  {{/if}}
}
